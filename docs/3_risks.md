# 存在的风险

对于MySQL数据库，4个连接自然比200个连接方便管理；但是对于应用服务器来说，只有4个连接，风险未免大了些——如果有一个用户请求执行慢查询，导致一个连接阻塞，那么其他三个连接的压力会明显增加；如果有四个这样的请求，那么岂非全部连接都阻塞了？

如果一个PHP进程维系多个数据库连接，在处理一个用户请求时阻塞了一个数据库连接后，可以调用其他空闲的数据库连接去处理其他用户请求，那么这个PHP进程对用户是依然可用（这算是连接池的概念）。
不过，Lumen框架使用的是同步MySQL客户端，每个PHP进程必须等待MySQL处理查询的结果，所以数据库连接池在这里根本用不上。

尽管Swoole HTTP服务器使用了IO多路复用机制epoll，不过其依然属于同步执行的范畴：一个worker在一个时间点上只能处理一个用户请求，若是用户请求执行慢查询（同步MySQL客户端执行）的话，会导致整个worker阻塞。

当然问题总有方法解决：

1. 第一种方法是提高Swoole服务器的worker数目，一般合理的worker数是CPU核数的1～4倍，worker数目高一些，Swoole服务器全阻塞的风险会低一些。
2. 第二种方法是利用Swoole提供的[异步MySQL客户端](https://wiki.swoole.com/wiki/page/517.html)，但是异步编程的代码风格与Lumen本身同步编程的代码风格很难兼容。
3. 所以，这里主要介绍第三种方法，[lumen-swoole-http](https://github.com/breeze2/lumen-swoole-http)提供的慢查询协程，其原理是：开发者知道当前用户请求会执行慢查询，于是在Lumen框架代码中向Swoole服务器声明，Swoole服务器会开启协程用异步MySQL客户端执行慢查询，再将结果返回声明处，继续往下执行，慢查询期间不阻塞worker进程。这样在Lumen层面可以保持同步编程风格，而异步编程的代码放在Swoole服务器层面。